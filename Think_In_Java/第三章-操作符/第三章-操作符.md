[源码GitHub地址](https://github.com/BruceEckel/TIJ4-code.git)

# 第三章 操作符

**在最底层，Java中的数据是通过使用操作符来操作的**

## 3.1 更简单的打印语句

本节介绍了作者写的一个类库，使用了**静态导入**功能（第六章介绍，java5出现）

> 练习1：使用“简短的”和正常的打印语句来编写一个程序
>
> 答：略

## 3.2 使用Java操作符

几乎所有操作符只能操作基本类型，但也有例外：=，==，!=能操作所有对象类型等

## 3.3 优先级

（用括号，不用记）

当编译器遇到一个String后面紧跟着一个+，而这个+又紧跟着一个非String类型的元素时，会尝试将这个非String类型的元素转换为String

## 3.4 赋值

- 基本类型存储了实际的数值，为其赋值时，直接将一个地方的内容复制到了另一个地方
- 对对象赋值时，真正操作的是对对象的引用，为其赋值时，是将“引用”从一个地方复制到另一个地方（不再使用的对象会被垃圾回收器自动清理）

```java
//: operators/Assignment.java
// Assignment with objects is a bit tricky.

class Tank {
    int level;
}

public class Assignment {
    public static void main(String[] args) {
        Tank t1 = new Tank();
        Tank t2 = new Tank();
        t1.level = 9;
        t2.level = 47;
        System.out.println("1: t1.level: " + t1.level +
                ", t2.level: " + t2.level);
        t1 = t2;
        System.out.println("2: t1.level: " + t1.level +
                ", t2.level: " + t2.level);
        t1.level = 27;
        System.out.println("3: t1.level: " + t1.level +
                ", t2.level: " + t2.level);
    }
} 
/* Output:
1: t1.level: 9, t2.level: 47
2: t1.level: 47, t2.level: 47
3: t1.level: 27, t2.level: 27
*///:~
```

> 练习2：创建一个包含float域的类，并用这个类来展示别名机制
>
> 答：
>
> ```java
> class Money{
>     float money;
> }
> public class Ex_03_02 {
>     public static void main(String[] args) {
>         Money m1 = new Money();
>         Money m2 = new Money();
>         m1.money = 5.20f;
>         m2.money = 13.14f;
>         System.out.println("m1.money:" + m1.money + ",m2.money:" + m2.money);
>         m1  = m2;
>         System.out.println("m1.money:" + m1.money + ",m2.money:" + m2.money);
>         m1.money = 5.20f;
>         System.out.println("m1.money:" + m1.money + ",m2.money:" + m2.money);
>     }
> }
> /*
> m1.money:5.2,m2.money:13.14
> m1.money:13.14,m2.money:13.14
> m1.money:5.2,m2.money:5.2
> */
> ```

### 3.4.1 方法调用中的别名问题

将一个对象传递入方法时，并不会在方法中传递其的副本，而是传递一个引用

```java
//: operators/PassObject.java
// Passing objects to methods may not be
// what you're used to.
class Letter {
    char c;
}

public class PassObject {
    static void f(Letter y) {
        y.c = 'z';
    }
    public static void main(String[] args) {
        Letter x = new Letter();
        x.c = 'a';
        System.out.println("1: x.c: " + x.c);
        f(x);
        System.out.println("2: x.c: " + x.c);
    }
} 
/* Output:
1: x.c: a
2: x.c: z
*///:~
```

> 练习3：创建一个包含一个float域的类，并用这个类来展示方法调用时的别名机制
>
> 答：
>
> ```java
> public class Ex_03_03 {
>     static void f(Money m){
>         m.money = 0;
>     }
> 
>     public static void main(String[] args) {
>         Money m = new Money();
>         m.money = 100;
>         System.out.println("m.money:" + m.money);
>         f(m);
>         System.out.println("m.money:" + m.money);
>     }
> }
> /*
> m.money:100.0
> m.money:0.0
> */
> ```

## 3.5 算数操作符

- +、-、*、/、%

- 整数除法会直接去掉结果的小数位（不是四舍五入）
- 支持运算赋值同时操作，如：x+=4

> 练习4：编写一个计算速度的程序，它所使用的距离和时间都是常量
>
> 答：
>
> ```java
> import java.util.Scanner;
> 
> public class Ex_03_04 {
>     static double speed(double distance, double time){
>         return distance / time;
>     }
> 
>     public static void main(String[] args) {
>         Scanner sc = new Scanner(System.in);
>         double distance = sc.nextDouble();
>         double time = sc.nextDouble();
>         System.out.printf("%.2f", speed(distance, time));
>     }
> }
> /*
> 233
> 666
> 0.35
> */
> ```

### 3.5.1 一元加、减操作符

x=a\*-b与x=a\*(-b)是一样的，最好是使用括号

一元减号用于转变数据的符号，而一元加号只是为了与一元减号相对应，但是它唯一的作用仅仅是将较小的类型操作提升为int

## 3.6 自动递增和递减

- 前缀式（++a、--a）：先计算后生成值
- 后缀式（a++、a--）：先生成值后运算

## 3.7 关系操作符

生成一个布尔值

### 3.7.1 测试对象的等价性

==与!=比较的是对象的引用

```java
//: operators/Equivalence.java

public class Equivalence {
    public static void main(String[] args) {
        Integer n1 = new Integer(47);
        Integer n2 = new Integer(47);
        System.out.println(n1 == n2);
        System.out.println(n1 != n2);
    }
} /* Output:
false
true
*///:~

```

使用equals()方法判断值

```java
//: operators/EqualsMethod.java

public class EqualsMethod {
    public static void main(String[] args) {
        Integer n1 = new Integer(47);
        Integer n2 = new Integer(47);
        System.out.println(n1.equals(n2));
    }
} /* Output:
true
*///:~
```

equals()方法默认行为是比较引用，需要在自己的类中实现equals()方法，才可能出现期望的结果

```java
//: operators/EqualsMethod2.java
// Default equals() does not compare contents.

class Value {
    int i;
}

public class EqualsMethod2 {
    public static void main(String[] args) {
        Value v1 = new Value();
        Value v2 = new Value();
        v1.i = v2.i = 100;
        System.out.println(v1.equals(v2));
    }
} /* Output:
false
*///:~
```

> 练习5：创建一个Dog类，包含两个String域：name、says。在main方法中创建两个对象，把它们名字叫声打印出来
>
> 答：
>
> ```java
> public class Dog {
>     String name;
>     String says;
> 
>     public static void main(String[] args) {
>         Dog d1 = new Dog();
>         Dog d2 = new Dog();
>         d1.name = "spot";
>         d1.says = "Ruff!";
>         d2.name = "scruffy";
>         d2.says = "Wurf!";
>         System.out.println("d1.name:"+d1.name+"\td1.says:"+d1.says);
>         System.out.println("d2.name:"+d2.name+"\td2.says:"+d2.says);
>     }
> }
> /*
> d1.name:spot	d1.says:Ruff!
> d2.name:scruffy	d2.says:Wurf!
> */
> ```

> 练习6：创建一个新的对象，名字也是spot，用==与equals()比较下
>
> 答：
>
> ```java
> public class Ex_03_06 {
>     public static void main(String[] args) {
>         Dog d1 = new Dog();
>         Dog d2 = new Dog();
>         d1.name = "spot";
>         d1.says = "Ruff!";
>         d2.name = "scruffy";
>         d2.says = "Wurf!";
>         Dog d3 = new Dog();
>         d3 = d1;
>         System.out.println("d1==d2?\t" + (d1==d2));
>         System.out.println("d1.equals(d2)?\t" + (d1.equals(d2)));
>         System.out.println("d1==d3?\t" + (d1==d3));
>         System.out.println("d1.equals(d3)?\t" + (d1.equals(d3)));
>     }
> }
> /*
> d1==d2?	false
> d1.equals(d2)?	false
> d1==d3?	true
> d1.equals(d3)?	true
> */
> ```

## 3.8 逻辑操作符

- &&、||、!
- 不可将非布尔值当作布尔值在逻辑表达式中使用
- 在使用了String值的地方使用了布尔值，布尔值会自动转换为适当的形式

> 练习7：编写一个程序模拟扔硬币的结果
>
> 答：
>
> ```java
> import java.util.Random;
> 
> public class Ex_03_07 {
>     static boolean flip_coin(){
>         Random random = new Random();
>         double temp = Math.random();
>         return temp < 0.5;
>     }
> 
>     public static void main(String[] args) {
>         int i = 1;
>         while(i < 6){
>             if(flip_coin())
>                 System.out.println("第"+i+"次为正面");
>             else
>                 System.out.println("第"+i+"次为反面");
>             i++;
>         }
>     }
> }
> /*
> 第1次为正面
> 第2次为反面
> 第3次为正面
> 第4次为反面
> 第5次为反面
> */
> ```

### 3.8.1 短路

一旦能明确无误地确定整个表达式地值，就不再计算表达式余下的部分

```java
//: operators/ShortCircuit.java
// Demonstrates short-circuiting behavior
// with logical operators.
public class ShortCircuit {
    static boolean test1(int val) {
        System.out.println("test1(" + val + ")");
        System.out.println("result: " + (val < 1));
        return val < 1;
    }
    static boolean test2(int val) {
        System.out.println("test2(" + val + ")");
        System.out.println("result: " + (val < 2));
        return val < 2;
    }
    static boolean test3(int val) {
        System.out.println("test3(" + val + ")");
        System.out.println("result: " + (val < 3));
        return val < 3;
    }
    public static void main(String[] args) {
        boolean b = test1(0) && test2(2) && test3(2);
        System.out.println("expression is " + b);
    }
} 
/* Output:
test1(0)
result: true
test2(2)
result: false
expression is false
*///:~
```

## 3.9 直接常量

















